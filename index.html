<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoSweep - Complete Platform</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- Web3 SDKs -->
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@walletconnect/web3-provider@1.8.0/dist/umd/index.min.js"></script>
    
    <!-- Payment SDKs -->
    <script src="https://js.stripe.com/v3/"></script>
    <script src="https://www.paypal.com/sdk/js?client-id=YOUR_PAYPAL_CLIENT_ID&currency=USD"></script>
    <script src="https://cdn.plaid.com/link/v2/stable/link-initialize.js"></script>
    
    <!-- Charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    
    <style>
        :root {
            --primary: #00ff88;
            --secondary: #0088ff;
            --dark: #0a0e27;
            --darker: #050813;
            --text: #e0e6ed;
            --text-dim: #8892a6;
            --error: #ff0044;
            --warning: #ffaa00;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Space Mono', monospace;
            background: var(--darker);
            color: var(--text);
            line-height: 1.6;
        }
        
        header {
            background: var(--dark);
            padding: 1.5rem 2rem;
            border-bottom: 2px solid var(--primary);
            position: sticky;
            top: 0;
            z-index: 1000;
        }
        
        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .logo {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            font-weight: 900;
            color: var(--primary);
        }
        
        .wallet-status {
            background: rgba(0, 255, 136, 0.1);
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            border: 1px solid var(--primary);
        }
        
        .tabs {
            background: var(--dark);
            padding: 0 2rem;
            display: flex;
            gap: 0.5rem;
            border-bottom: 1px solid rgba(0, 255, 136, 0.2);
        }
        
        .tab-btn {
            padding: 1rem 2rem;
            background: none;
            border: none;
            border-bottom: 3px solid transparent;
            color: var(--text-dim);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }
        
        .tab-btn:hover {
            color: var(--primary);
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .section {
            background: rgba(10, 14, 39, 0.6);
            border: 1px solid var(--primary);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
        }
        
        .section h2 {
            font-family: 'Orbitron', sans-serif;
            color: var(--primary);
            margin-bottom: 1.5rem;
            font-size: 1.8rem;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }
        
        .card {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 12px;
            padding: 1.5rem;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .card:hover {
            border-color: var(--primary);
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.2);
        }
        
        .card-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            display: block;
        }
        
        .card-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: var(--primary);
            margin-bottom: 0.5rem;
        }
        
        .card-desc {
            color: var(--text-dim);
            font-size: 0.9rem;
        }
        
        .btn {
            padding: 1rem 2rem;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 8px;
            color: var(--dark);
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 1rem;
            width: 100%;
            margin: 0.5rem 0;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 255, 136, 0.3);
        }
        
        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-secondary {
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, var(--error), #aa00ff);
        }
        
        input, select, textarea {
            width: 100%;
            padding: 1rem;
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            color: var(--text);
            font-family: 'Space Mono', monospace;
            margin: 0.5rem 0;
            font-size: 1rem;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(0, 255, 136, 0.1);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }
        
        th {
            background: rgba(0, 255, 136, 0.1);
            padding: 1rem;
            text-align: left;
            color: var(--primary);
            font-weight: 600;
        }
        
        td {
            padding: 1rem;
            border-top: 1px solid rgba(0, 255, 136, 0.1);
        }
        
        tr:hover {
            background: rgba(0, 255, 136, 0.05);
        }
        
        .status-message {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: none;
        }
        
        .status-message.show {
            display: block;
        }
        
        .status-success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--primary);
            color: var(--primary);
        }
        
        .status-error {
            background: rgba(255, 0, 68, 0.1);
            border: 1px solid var(--error);
            color: var(--error);
        }
        
        .status-info {
            background: rgba(0, 136, 255, 0.1);
            border: 1px solid var(--secondary);
            color: var(--secondary);
        }
        
        #card-element {
            padding: 1rem;
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.3);
            border-radius: 8px;
            margin: 1rem 0;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin: 2rem 0;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 2rem;
        }
        
        .loading.show {
            display: block;
        }
        
        .spinner {
            border: 4px solid rgba(0, 255, 136, 0.1);
            border-top: 4px solid var(--primary);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .tabs {
                overflow-x: auto;
            }
        }
    </style>
</head>
<body>
    <header>
        <div class="header-content">
            <div class="logo">üöÄ CryptoSweep</div>
            <div class="wallet-status" id="headerWalletStatus">
                <span id="connectedAddress">Not Connected</span>
            </div>
        </div>
    </header>
    
    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('home', event)">Home</button>
        <button class="tab-btn" onclick="switchTab('wallets', event)">Wallets</button>
        <button class="tab-btn" onclick="switchTab('payments', event)">Payments</button>
        <button class="tab-btn" onclick="switchTab('sweeps', event)">Sweeps</button>
        <button class="tab-btn" onclick="switchTab('analytics', event)">Analytics</button>
        <button class="tab-btn" onclick="switchTab('admin', event)">Admin</button>
    </div>
    
    <div class="container">
        <!-- HOME TAB -->
        <div id="home" class="tab-content active">
            <div class="section">
                <h2>Welcome to CryptoSweep</h2>
                <p style="margin-bottom: 2rem;">Enterprise-grade multi-chain wallet sweeping platform with real-time monitoring, automated security, and comprehensive analytics.</p>
                
                <div class="grid">
                    <div class="card" onclick="switchTab('wallets', event)">
                        <span class="card-icon">üëõ</span>
                        <div class="card-title">Connect Wallet</div>
                        <div class="card-desc">MetaMask, WalletConnect, Coinbase, Cake Wallet, Zashi</div>
                    </div>
                    
                    <div class="card" onclick="switchTab('payments', event)">
                        <span class="card-icon">üí≥</span>
                        <div class="card-title">Add Funds</div>
                        <div class="card-desc">Stripe, PayPal, Plaid, Cash App</div>
                    </div>
                    
                    <div class="card" onclick="switchTab('sweeps', event)">
                        <span class="card-icon">‚ö°</span>
                        <div class="card-title">Execute Sweeps</div>
                        <div class="card-desc">Multi-chain automated sweeping</div>
                    </div>
                    
                    <div class="card" onclick="switchTab('analytics', event)">
                        <span class="card-icon">üìä</span>
                        <div class="card-title">Analytics</div>
                        <div class="card-desc">Real-time performance metrics</div>
                    </div>
                </div>
                
                <div class="grid" style="margin-top: 2rem;">
                    <div class="section">
                        <h3 style="color: var(--primary); margin-bottom: 1rem;">System Status</h3>
                        <div id="systemStatus">Loading...</div>
                    </div>
                    
                    <div class="section">
                        <h3 style="color: var(--primary); margin-bottom: 1rem;">Quick Stats</h3>
                        <div id="quickStats">Loading...</div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- WALLETS TAB -->
        <div id="wallets" class="tab-content">
            <div class="section">
                <h2>Connect Your Wallet</h2>
                <div class="grid">
                    <div class="card" onclick="connectMetaMask()">
                        <span class="card-icon">ü¶ä</span>
                        <div class="card-title">MetaMask</div>
                        <div class="card-desc">Most popular Ethereum wallet</div>
                    </div>
                    
                    <div class="card" onclick="connectWalletConnect()">
                        <span class="card-icon">üîó</span>
                        <div class="card-title">WalletConnect</div>
                        <div class="card-desc">Connect with QR code</div>
                    </div>
                    
                    <div class="card" onclick="connectCoinbase()">
                        <span class="card-icon">üíé</span>
                        <div class="card-title">Coinbase Wallet</div>
                        <div class="card-desc">Self-custody wallet</div>
                    </div>
                    
                    <div class="card" onclick="connectCakeWallet()">
                        <span class="card-icon">üéÇ</span>
                        <div class="card-title">Cake Wallet</div>
                        <div class="card-desc">Monero & multi-coin</div>
                    </div>
                    
                    <div class="card" onclick="connectZashiWallet()">
                        <span class="card-icon">üõ°Ô∏è</span>
                        <div class="card-title">Zashi</div>
                        <div class="card-desc">Zcash privacy wallet</div>
                    </div>
                </div>
                
                <div id="walletStatus" class="status-message"></div>
                
                <div class="section" id="walletInfo" style="display: none;">
                    <h3 style="color: var(--primary); margin-bottom: 1rem;">Connected Wallet</h3>
                    <table>
                        <tr>
                            <th>Type</th>
                            <td id="walletType">-</td>
                        </tr>
                        <tr>
                            <th>Address</th>
                            <td id="walletAddress">-</td>
                        </tr>
                        <tr>
                            <th>Network</th>
                            <td id="walletNetwork">-</td>
                        </tr>
                        <tr>
                            <th>Balance</th>
                            <td>
                                <span id="walletBalance">-</span>
                                <button onclick="refreshWalletBalance()" style="margin-left: 1rem; padding: 0.3rem 0.8rem; background: transparent; border: 1px solid var(--primary); color: var(--primary); border-radius: 4px; cursor: pointer; font-size: 0.8rem;">‚Üª Refresh</button>
                            </td>
                        </tr>
                    </table>
                    
                    <div style="margin: 1rem 0;">
                        <label>Switch Network</label>
                        <select id="networkSwitcher" onchange="switchNetwork(parseInt(this.value))">
                            <option value="1">Ethereum Mainnet</option>
                            <option value="56">BNB Smart Chain</option>
                            <option value="137">Polygon</option>
                            <option value="42161">Arbitrum</option>
                            <option value="10">Optimism</option>
                            <option value="43114">Avalanche</option>
                            <option value="8453">Base</option>
                            <option value="250">Fantom</option>
                        </select>
                    </div>
                    
                    <button class="btn btn-danger" onclick="disconnectWallet()">Disconnect</button>
                </div>
            </div>
        </div>
        
        <!-- PAYMENTS TAB -->
        <div id="payments" class="tab-content">
            <div class="section">
                <h2>Add Funds to Your Account</h2>
                
                <div>
                    <label>Amount (USD)</label>
                    <input type="number" id="paymentAmount" placeholder="Enter amount" min="10" value="100">
                </div>
                
                <div class="grid">
                    <div class="card" onclick="selectPayment('stripe')">
                        <span class="card-icon">üí≥</span>
                        <div class="card-title">Credit Card</div>
                        <div class="card-desc">Via Stripe - Fee: 2.9% + $0.30</div>
                    </div>
                    
                    <div class="card" onclick="selectPayment('paypal')">
                        <span class="card-icon">üÖøÔ∏è</span>
                        <div class="card-title">PayPal</div>
                        <div class="card-desc">Fast checkout - Fee: 2.9% + $0.30</div>
                    </div>
                    
                    <div class="card" onclick="selectPayment('plaid')">
                        <span class="card-icon">üè¶</span>
                        <div class="card-title">Bank Transfer</div>
                        <div class="card-desc">ACH via Plaid - Fee: 0.8%</div>
                    </div>
                    
                    <div class="card" onclick="selectPayment('cashapp')">
                        <span class="card-icon">üíµ</span>
                        <div class="card-title">Cash App</div>
                        <div class="card-desc">$Cashtag - Fee: 1.5%</div>
                    </div>
                </div>
                
                <div id="paymentStatus" class="status-message"></div>
                
                <div id="stripeForm" style="display: none;">
                    <h3 style="color: var(--primary); margin: 2rem 0 1rem;">Credit Card Payment</h3>
                    <div id="card-element"></div>
                    <button class="btn" id="stripePayBtn" onclick="processStripePayment()">Pay Now</button>
                </div>
                
                <div id="paypalForm" style="display: none;">
                    <h3 style="color: var(--primary); margin: 2rem 0 1rem;">PayPal Payment</h3>
                    <div id="paypal-button-container"></div>
                </div>
                
                <div id="cashappForm" style="display: none;">
                    <h3 style="color: var(--primary); margin: 2rem 0 1rem;">Cash App Payment</h3>
                    <input type="text" id="cashtag" placeholder="Your $Cashtag">
                    <button class="btn" onclick="processCashApp()">Pay with Cash App</button>
                </div>
            </div>
        </div>
        
        <!-- SWEEPS TAB -->
        <div id="sweeps" class="tab-content">
            <div class="section">
                <h2>Execute Sweeps</h2>
                
                <div>
                    <label>Select Chain</label>
                    <select id="sweepChain">
                        <option value="1">Ethereum</option>
                        <option value="56">BSC</option>
                        <option value="137">Polygon</option>
                        <option value="42161">Arbitrum</option>
                        <option value="10">Optimism</option>
                        <option value="43114">Avalanche</option>
                        <option value="8453">Base</option>
                        <option value="250">Fantom</option>
                    </select>
                </div>
                
                <div>
                    <label>Wallet Address to Sweep</label>
                    <input type="text" id="sweepAddress" placeholder="0x...">
                </div>
                
                <div>
                    <label>Batch Sweep (one address per line)</label>
                    <textarea id="batchSweepAddresses" rows="5" placeholder="0x...&#10;0x...&#10;0x..." style="display: none;"></textarea>
                    <button class="btn btn-secondary" onclick="toggleBatchMode()" style="margin-top: 0.5rem;">Toggle Batch Mode</button>
                </div>
                
                <div style="display: flex; gap: 1rem;">
                    <button class="btn" onclick="executeSweep(false)">Execute Sweep</button>
                    <button class="btn btn-secondary" onclick="executeSweep(true)">Force Sweep</button>
                    <button class="btn btn-secondary" onclick="executeBatchSweep()" id="batchSweepBtn" style="display: none;">Batch Sweep</button>
                </div>
                
                <div id="sweepStatus" class="status-message"></div>
                
                <h3 style="color: var(--primary); margin: 2rem 0 1rem;">Recent Sweeps</h3>
                <div class="loading" id="sweepLoading">
                    <div class="spinner"></div>
                    <p>Loading sweeps...</p>
                </div>
                <div id="sweepHistory"></div>
            </div>
        </div>
        
        <!-- ANALYTICS TAB -->
        <div id="analytics" class="tab-content">
            <div class="section">
                <h2>Analytics Dashboard</h2>
                
                <div class="grid">
                    <div class="section">
                        <h3 style="color: var(--primary);">Total Sweeps</h3>
                        <div style="font-size: 3rem; font-family: 'Orbitron', sans-serif; color: var(--primary);" id="totalSweeps">0</div>
                    </div>
                    
                    <div class="section">
                        <h3 style="color: var(--primary);">Total Volume</h3>
                        <div style="font-size: 3rem; font-family: 'Orbitron', sans-serif; color: var(--primary);" id="totalVolume">$0</div>
                    </div>
                    
                    <div class="section">
                        <h3 style="color: var(--primary);">Success Rate</h3>
                        <div style="font-size: 3rem; font-family: 'Orbitron', sans-serif; color: var(--primary);" id="successRate">0%</div>
                    </div>
                    
                    <div class="section">
                        <h3 style="color: var(--primary);">Active Chains</h3>
                        <div style="font-size: 3rem; font-family: 'Orbitron', sans-serif; color: var(--primary);" id="activeChains">8</div>
                    </div>
                </div>
                
                <div class="section">
                    <h3 style="color: var(--primary); margin-bottom: 1rem;">Sweep Activity (7 Days)</h3>
                    <div class="chart-container">
                        <canvas id="activityChart"></canvas>
                    </div>
                </div>
                
                <button class="btn btn-secondary" onclick="loadAnalytics()">Refresh Analytics</button>
            </div>
        </div>
        
        <!-- ADMIN TAB -->
        <div id="admin" class="tab-content">
            <div class="section">
                <h2>Admin Control Panel</h2>
                
                <div class="grid">
                    <button class="btn" onclick="pauseAllSweeps()">‚è∏Ô∏è Pause All Sweeps</button>
                    <button class="btn" onclick="resumeAllSweeps()">‚ñ∂Ô∏è Resume All Sweeps</button>
                    <button class="btn btn-secondary" onclick="checkServices()">üîß Check Services</button>
                    <button class="btn btn-danger" onclick="emergencyShutdown()">üö® Emergency Stop</button>
                </div>
                
                <div id="adminStatus" class="status-message"></div>
                
                <h3 style="color: var(--primary); margin: 2rem 0 1rem;">Service Status</h3>
                <div id="serviceStatus">Loading...</div>
                
                <h3 style="color: var(--primary); margin: 2rem 0 1rem;">WAF Statistics</h3>
                <div class="grid">
                    <div class="section">
                        <h4 style="color: var(--text-dim);">Blocked Requests</h4>
                        <div style="font-size: 2rem; color: var(--primary);" id="blockedRequests">0</div>
                    </div>
                    <div class="section">
                        <h4 style="color: var(--text-dim);">Blacklisted IPs</h4>
                        <div style="font-size: 2rem; color: var(--primary);" id="blacklistedIPs">0</div>
                    </div>
                    <div class="section">
                        <h4 style="color: var(--text-dim);">Whitelisted IPs</h4>
                        <div style="font-size: 2rem; color: var(--primary);" id="whitelistedIPs">0</div>
                    </div>
                    <div class="section">
                        <h4 style="color: var(--text-dim);">Threat Level</h4>
                        <div style="font-size: 2rem; color: var(--primary);" id="threatLevel">Low</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== CONFIGURATION ==========
        const API_BASE = 'http://localhost:8080';
        
        // ========== STATE ==========
        let web3;
        let currentAccount;
        let currentWalletType;
        let authToken = localStorage.getItem('authToken');
        let stripe;
        let cardElement;
        let activityChart;
        let walletConnectProvider;
        let plaidHandler;
        let monitoredAddresses = new Set();
        let sweepQueue = [];
        let isProcessingSweep = false;
        
        // ========== INITIALIZATION ==========
        document.addEventListener('DOMContentLoaded', async () => {
            console.log('Initializing CryptoSweep...');
            
            // Check if already connected
            const savedAddress = localStorage.getItem('walletAddress');
            const savedType = localStorage.getItem('walletType');
            const savedChain = localStorage.getItem('walletChain');
            
            if (savedAddress && savedType) {
                currentAccount = savedAddress;
                currentWalletType = savedType;
                updateWalletDisplay(savedType, savedAddress);
                
                // Attempt to reconnect
                if (savedType === 'MetaMask' && typeof window.ethereum !== 'undefined') {
                    try {
                        web3 = new Web3(window.ethereum);
                        const accounts = await web3.eth.getAccounts();
                        if (accounts[0]?.toLowerCase() === savedAddress.toLowerCase()) {
                            const chainId = await web3.eth.getChainId();
                            const balance = await web3.eth.getBalance(savedAddress);
                            const balanceEth = web3.utils.fromWei(balance, 'ether');
                            updateWalletDisplay(savedType, savedAddress, getNetworkName(chainId), balanceEth + ' ETH');
                        }
                    } catch (error) {
                        console.log('Could not auto-reconnect MetaMask:', error);
                    }
                }
            }
            
            // Initialize WebSocket for real-time updates
            initWebSocket();
            
            // Load initial data
            await loadSystemStatus();
            await loadQuickStats();
            
            // Set up periodic updates
            setInterval(loadSystemStatus, 30000); // Every 30 seconds
            setInterval(loadQuickStats, 60000); // Every minute
        });
        
        // ========== TAB SWITCHING ==========
        function switchTab(tabName, event) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            if (event && event.target) {
                event.target.classList.add('active');
            }
            
            if (tabName === 'sweeps') {
                loadSweepHistory();
            } else if (tabName === 'analytics') {
                loadAnalytics();
            } else if (tabName === 'admin') {
                checkServices();
                loadWAFStats();
            }
        }
        
        // ========== API HELPER ==========
        async function fetchAPI(endpoint, options = {}) {
            try {
                const headers = {
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                if (authToken) {
                    headers['Authorization'] = `Bearer ${authToken}`;
                }
                
                const response = await fetch(`${API_BASE}${endpoint}`, {
                    ...options,
                    headers
                });
                
                if (!response.ok) {
                    if (response.status === 401) {
                        showStatus('walletStatus', 'Session expired. Please reconnect.', 'error');
                        localStorage.removeItem('authToken');
                        authToken = null;
                        throw new Error('Unauthorized');
                    }
                    
                    const errorData = await response.json().catch(() => null);
                    throw new Error(errorData?.error || errorData?.message || `HTTP ${response.status}`);
                }
                
                return await response.json();
            } catch (error) {
                console.error('API Error:', endpoint, error);
                throw error;
            }
        }
        
        // ========== WALLET CONNECTIONS ==========
        
        async function connectMetaMask() {
            if (typeof window.ethereum === 'undefined') {
                showStatus('walletStatus', 'MetaMask not installed. Opening download page...', 'error');
                window.open('https://metamask.io/download/', '_blank');
                return;
            }
            
            try {
                showStatus('walletStatus', 'Connecting to MetaMask...', 'info');
                
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                currentAccount = accounts[0];
                web3 = new Web3(window.ethereum);
                currentWalletType = 'MetaMask';
                
                const chainId = await web3.eth.getChainId();
                const balance = await web3.eth.getBalance(currentAccount);
                const balanceEth = web3.utils.fromWei(balance, 'ether');
                
                // Get gas price for current network
                const gasPrice = await web3.eth.getGasPrice();
                const gasPriceGwei = web3.utils.fromWei(gasPrice, 'gwei');
                
                await authenticateUser(currentAccount, 'metamask');
                await registerWalletWithMonitor(currentAccount, chainId);
                
                updateWalletDisplay('MetaMask', currentAccount, getNetworkName(chainId), `${parseFloat(balanceEth).toFixed(4)} ETH`);
                showStatus('walletStatus', `MetaMask connected successfully! Gas: ${parseFloat(gasPriceGwei).toFixed(2)} Gwei`, 'success');
                
                // Listen for account and network changes
                window.ethereum.on('accountsChanged', handleAccountChange);
                window.ethereum.on('chainChanged', handleChainChange);
                
            } catch (error) {
                if (error.code === 4001) {
                    showStatus('walletStatus', 'Connection cancelled by user', 'info');
                } else {
                    showStatus('walletStatus', 'MetaMask connection failed: ' + error.message, 'error');
                }
            }
        }
        
        async function handleChainChange(chainIdHex) {
            const chainId = parseInt(chainIdHex, 16);
            
            if (currentAccount && web3) {
                try {
                    const balance = await web3.eth.getBalance(currentAccount);
                    const balanceEth = web3.utils.fromWei(balance, 'ether');
                    
                    // Re-register with new chain
                    await registerWalletWithMonitor(currentAccount, chainId);
                    
                    updateWalletDisplay(currentWalletType, currentAccount, getNetworkName(chainId), `${parseFloat(balanceEth).toFixed(4)} ETH`);
                    showStatus('walletStatus', `Network changed to ${getNetworkName(chainId)}`, 'info');
                    
                    localStorage.setItem('walletChain', chainId);
                } catch (error) {
                    console.error('Chain change handling error:', error);
                    window.location.reload();
                }
            } else {
                window.location.reload();
            }
        }
        
        async function switchNetwork(chainId) {
            if (!window.ethereum) {
                showStatus('walletStatus', 'No wallet connected', 'error');
                return;
            }
            
            const chainParams = {
                1: null, // Mainnet - no params needed
                56: {
                    chainId: '0x38',
                    chainName: 'BNB Smart Chain',
                    nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
                    rpcUrls: ['https://bsc-dataseed.binance.org/'],
                    blockExplorerUrls: ['https://bscscan.com/']
                },
                137: {
                    chainId: '0x89',
                    chainName: 'Polygon',
                    nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
                    rpcUrls: ['https://polygon-rpc.com/'],
                    blockExplorerUrls: ['https://polygonscan.com/']
                },
                42161: {
                    chainId: '0xa4b1',
                    chainName: 'Arbitrum One',
                    nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                    rpcUrls: ['https://arb1.arbitrum.io/rpc'],
                    blockExplorerUrls: ['https://arbiscan.io/']
                },
                10: {
                    chainId: '0xa',
                    chainName: 'Optimism',
                    nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                    rpcUrls: ['https://mainnet.optimism.io'],
                    blockExplorerUrls: ['https://optimistic.etherscan.io/']
                },
                43114: {
                    chainId: '0xa86a',
                    chainName: 'Avalanche C-Chain',
                    nativeCurrency: { name: 'AVAX', symbol: 'AVAX', decimals: 18 },
                    rpcUrls: ['https://api.avax.network/ext/bc/C/rpc'],
                    blockExplorerUrls: ['https://snowtrace.io/']
                },
                8453: {
                    chainId: '0x2105',
                    chainName: 'Base',
                    nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                    rpcUrls: ['https://mainnet.base.org'],
                    blockExplorerUrls: ['https://basescan.org/']
                },
                250: {
                    chainId: '0xfa',
                    chainName: 'Fantom Opera',
                    nativeCurrency: { name: 'FTM', symbol: 'FTM', decimals: 18 },
                    rpcUrls: ['https://rpc.ftm.tools/'],
                    blockExplorerUrls: ['https://ftmscan.com/']
                }
            };
            
            try {
                const hexChainId = '0x' + chainId.toString(16);
                
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: hexChainId }]
                });
            } catch (error) {
                if (error.code === 4902) {
                    // Chain not added, try adding it
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [chainParams[chainId]]
                        });
                    } catch (addError) {
                        showStatus('walletStatus', 'Failed to add network: ' + addError.message, 'error');
                    }
                } else {
                    showStatus('walletStatus', 'Failed to switch network: ' + error.message, 'error');
                }
            }
        }
        
        async function connectWalletConnect() {
            try {
                showStatus('walletStatus', 'Initializing WalletConnect...', 'info');
                
                walletConnectProvider = new WalletConnectProvider.default({
                    rpc: {
                        1: 'https://mainnet.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161',
                        56: 'https://bsc-dataseed.binance.org/',
                        137: 'https://polygon-rpc.com/',
                        42161: 'https://arb1.arbitrum.io/rpc',
                        10: 'https://mainnet.optimism.io',
                        43114: 'https://api.avax.network/ext/bc/C/rpc',
                        8453: 'https://mainnet.base.org',
                        250: 'https://rpc.ftm.tools/'
                    }
                });
                
                await walletConnectProvider.enable();
                web3 = new Web3(walletConnectProvider);
                
                const accounts = await web3.eth.getAccounts();
                currentAccount = accounts[0];
                currentWalletType = 'WalletConnect';
                
                const chainId = await web3.eth.getChainId();
                const balance = await web3.eth.getBalance(currentAccount);
                const balanceEth = web3.utils.fromWei(balance, 'ether');
                
                await authenticateUser(currentAccount, 'walletconnect');
                await registerWalletWithMonitor(currentAccount, chainId);
                
                updateWalletDisplay('WalletConnect', currentAccount, getNetworkName(chainId), balanceEth + ' ETH');
                showStatus('walletStatus', 'WalletConnect connected successfully!', 'success');
                
                walletConnectProvider.on('disconnect', disconnectWallet);
                walletConnectProvider.on('accountsChanged', handleAccountChange);
                
            } catch (error) {
                showStatus('walletStatus', 'WalletConnect failed: ' + error.message, 'error');
            }
        }
        
        async function connectCoinbase() {
            try {
                if (window.ethereum && window.ethereum.isCoinbaseWallet) {
                    showStatus('walletStatus', 'Connecting to Coinbase Wallet...', 'info');
                    
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    currentAccount = accounts[0];
                    web3 = new Web3(window.ethereum);
                    currentWalletType = 'Coinbase Wallet';
                    
                    const chainId = await web3.eth.getChainId();
                    const balance = await web3.eth.getBalance(currentAccount);
                    const balanceEth = web3.utils.fromWei(balance, 'ether');
                    
                    await authenticateUser(currentAccount, 'coinbase');
                    await registerWalletWithMonitor(currentAccount, chainId);
                    
                    updateWalletDisplay('Coinbase Wallet', currentAccount, getNetworkName(chainId), balanceEth + ' ETH');
                    showStatus('walletStatus', 'Coinbase Wallet connected!', 'success');
                } else {
                    showStatus('walletStatus', 'Coinbase Wallet not detected. Opening download page...', 'error');
                    window.open('https://www.coinbase.com/wallet', '_blank');
                }
            } catch (error) {
                showStatus('walletStatus', 'Coinbase connection failed: ' + error.message, 'error');
            }
        }
        
        async function connectCakeWallet() {
            showStatus('walletStatus', 'Cake Wallet: Use WalletConnect to connect your mobile wallet', 'info');
            setTimeout(() => connectWalletConnect(), 2000);
        }
        
        async function connectZashiWallet() {
            showStatus('walletStatus', 'Zashi: Opening Zashi wallet website for installation', 'info');
            window.open('https://zashi.app/', '_blank');
        }
        
        async function authenticateUser(address, walletType) {
            try {
                const response = await fetchAPI('/auth/login', {
                    method: 'POST',
                    body: JSON.stringify({
                        username: 'admin',
                        password: 'changeme'
                    })
                });
                
                if (response && response.token) {
                    authToken = response.token;
                    localStorage.setItem('authToken', authToken);
                    localStorage.setItem('walletAddress', address);
                    localStorage.setItem('walletType', walletType);
                    
                    // Initialize WebSocket after successful auth
                    initWebSocket();
                    
                    // Set up token refresh (refresh 5 minutes before expiry)
                    if (response.expiresIn) {
                        const refreshTime = (response.expiresIn - 300) * 1000;
                        setTimeout(refreshAuthToken, refreshTime);
                    }
                }
            } catch (error) {
                console.error('Authentication failed:', error);
                throw new Error('Failed to authenticate with backend');
            }
        }
        
        async function refreshAuthToken() {
            try {
                const response = await fetchAPI('/auth/refresh', {
                    method: 'POST',
                    body: JSON.stringify({ token: authToken })
                });
                
                if (response && response.token) {
                    authToken = response.token;
                    localStorage.setItem('authToken', authToken);
                    
                    if (response.expiresIn) {
                        const refreshTime = (response.expiresIn - 300) * 1000;
                        setTimeout(refreshAuthToken, refreshTime);
                    }
                }
            } catch (error) {
                console.error('Token refresh failed:', error);
                disconnectWallet();
            }
        }
        
        async function registerWalletWithMonitor(address, chainId) {
            try {
                const chainName = getChainName(chainId);
                const response = await fetchAPI('/api/monitor/addresses', {
                    method: 'POST',
                    body: JSON.stringify({
                        address: address,
                        chain: chainName,
                        autoSweep: false,
                        notifyOnDeposit: true,
                        minBalance: '0.01'
                    })
                });
                
                if (response && response.success) {
                    monitoredAddresses.add(`${address}-${chainName}`);
                    console.log(`Wallet registered for monitoring: ${address} on ${chainName}`);
                    
                    // Store chain info
                    localStorage.setItem('walletChain', chainId);
                }
            } catch (error) {
                console.error('Failed to register wallet with monitor:', error);
            }
        }
        
        async function unregisterWalletFromMonitor(address, chainId) {
            try {
                const chainName = getChainName(chainId);
                await fetchAPI(`/api/monitor/addresses/${address}/${chainName}`, {
                    method: 'DELETE'
                });
                
                monitoredAddresses.delete(`${address}-${chainName}`);
                console.log(`Wallet unregistered from monitoring: ${address} on ${chainName}`);
            } catch (error) {
                console.error('Failed to unregister wallet:', error);
            }
        }
        
        function updateWalletDisplay(type, address, network = 'Connected', balance = 'Loading...') {
            document.getElementById('connectedAddress').textContent = 
                type + ': ' + address.substring(0, 6) + '...' + address.substring(address.length - 4);
            
            document.getElementById('walletType').textContent = type;
            document.getElementById('walletAddress').textContent = address;
            document.getElementById('walletNetwork').textContent = network;
            document.getElementById('walletBalance').textContent = balance;
            
            // Update network switcher if present
            const switcher = document.getElementById('networkSwitcher');
            if (switcher && web3) {
                web3.eth.getChainId().then(chainId => {
                    switcher.value = chainId;
                }).catch(console.error);
            }
            
            document.getElementById('walletInfo').style.display = 'block';
        }
        
        async function refreshWalletBalance() {
            if (!currentAccount || !web3) {
                showStatus('walletStatus', 'No wallet connected', 'error');
                return;
            }
            
            try {
                const balance = await web3.eth.getBalance(currentAccount);
                const balanceEth = web3.utils.fromWei(balance, 'ether');
                document.getElementById('walletBalance').textContent = `${parseFloat(balanceEth).toFixed(4)} ETH`;
                showStatus('walletStatus', 'Balance updated', 'success');
            } catch (error) {
                showStatus('walletStatus', 'Failed to refresh balance: ' + error.message, 'error');
            }
        }
        
        function disconnectWallet() {
            // Close WebSocket
            if (ws) {
                ws.close();
                ws = null;
            }
            
            // Disconnect WalletConnect
            if (walletConnectProvider) {
                try {
                    walletConnectProvider.disconnect();
                } catch (error) {
                    console.error('WalletConnect disconnect error:', error);
                }
                walletConnectProvider = null;
            }
            
            // Unregister from monitoring
            if (currentAccount) {
                const chainId = localStorage.getItem('walletChain');
                if (chainId) {
                    unregisterWalletFromMonitor(currentAccount, parseInt(chainId));
                }
            }
            
            // Clear state
            localStorage.clear();
            currentAccount = null;
            currentWalletType = null;
            web3 = null;
            authToken = null;
            monitoredAddresses.clear();
            
            // Update UI
            document.getElementById('connectedAddress').textContent = 'Not Connected';
            document.getElementById('walletInfo').style.display = 'none';
            showStatus('walletStatus', 'Wallet disconnected', 'info');
        }
        
        function handleAccountChange(accounts) {
            if (accounts.length === 0) {
                disconnectWallet();
            } else {
                window.location.reload();
            }
        }
        
        function getNetworkName(chainId) {
            const networks = {
                1: 'Ethereum Mainnet',
                56: 'BSC',
                137: 'Polygon',
                42161: 'Arbitrum',
                10: 'Optimism',
                43114: 'Avalanche',
                250: 'Fantom',
                8453: 'Base'
            };
            return networks[chainId] || `Chain ${chainId}`;
        }
        
        function getChainName(chainId) {
            const chains = {
                1: 'ethereum',
                56: 'bsc',
                137: 'polygon',
                42161: 'arbitrum',
                10: 'optimism',
                43114: 'avalanche',
                250: 'fantom',
                8453: 'base'
            };
            return chains[chainId] || 'ethereum';
        }
        
        // ========== PAYMENT METHODS ==========
        
        function selectPayment(method) {
            document.getElementById('stripeForm').style.display = 'none';
            document.getElementById('paypalForm').style.display = 'none';
            document.getElementById('cashappForm').style.display = 'none';
            
            if (method === 'stripe') {
                if (typeof Stripe !== 'undefined' && !stripe) {
                    stripe = Stripe('pk_test_51234567890');
                }
                
                if (stripe && !cardElement) {
                    const elements = stripe.elements();
                    cardElement = elements.create('card', {
                        style: {
                            base: {
                                color: '#e0e6ed',
                                fontFamily: 'Space Mono, monospace',
                                fontSize: '16px'
                            }
                        }
                    });
                }
                
                document.getElementById('stripeForm').style.display = 'block';
                
                if (cardElement && !cardElement._mounted) {
                    cardElement.mount('#card-element');
                    cardElement._mounted = true;
                }
            } else if (method === 'paypal') {
                document.getElementById('paypalForm').style.display = 'block';
                initPayPal();
            } else if (method === 'plaid') {
                initiateACH();
            } else if (method === 'cashapp') {
                document.getElementById('cashappForm').style.display = 'block';
            }
        }
        
        async function processStripePayment() {
            const amount = parseFloat(document.getElementById('paymentAmount').value);
            
            if (!amount || amount < 10) {
                showStatus('paymentStatus', 'Minimum amount is $10', 'error');
                return;
            }
            
            if (!stripe || !cardElement) {
                showStatus('paymentStatus', 'Stripe not initialized', 'error');
                return;
            }
            
            const btn = document.getElementById('stripePayBtn');
            btn.disabled = true;
            btn.textContent = 'Processing...';
            
            try {
                showStatus('paymentStatus', 'Processing payment...', 'info');
                
                const response = await fetchAPI('/api/payment/stripe/create', {
                    method: 'POST',
                    body: JSON.stringify({ amount })
                });
                
                if (!response || !response.clientSecret) {
                    throw new Error('Failed to create payment intent');
                }
                
                const { error } = await stripe.confirmCardPayment(response.clientSecret, {
                    payment_method: { card: cardElement }
                });
                
                if (error) {
                    showStatus('paymentStatus', 'Payment failed: ' + error.message, 'error');
                } else {
                    showStatus('paymentStatus', 'Payment successful! Funds added to your account.', 'success');
                    document.getElementById('stripeForm').style.display = 'none';
                    cardElement.clear();
                }
            } catch (error) {
                showStatus('paymentStatus', 'Payment error: ' + error.message, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = 'Pay Now';
            }
        }
        
        function initPayPal() {
            const amount = document.getElementById('paymentAmount').value || 100;
            
            document.getElementById('paypal-button-container').innerHTML = '';
            
            if (typeof paypal === 'undefined') {
                showStatus('paymentStatus', 'PayPal SDK not loaded', 'error');
                return;
            }
            
            paypal.Buttons({
                createOrder: (data, actions) => {
                    return actions.order.create({
                        purchase_units: [{
                            amount: { value: amount }
                        }]
                    });
                },
                onApprove: async (data, actions) => {
                    const details = await actions.order.capture();
                    
                    try {
                        await fetchAPI('/api/payment/paypal/complete', {
                            method: 'POST',
                            body: JSON.stringify({
                                orderId: data.orderID,
                                amount: amount
                            })
                        });
                        
                        showStatus('paymentStatus', 'PayPal payment successful!', 'success');
                        document.getElementById('paypalForm').style.display = 'none';
                    } catch (error) {
                        showStatus('paymentStatus', 'Failed to record payment: ' + error.message, 'error');
                    }
                },
                onError: (err) => {
                    showStatus('paymentStatus', 'PayPal payment failed', 'error');
                    console.error('PayPal error:', err);
                }
            }).render('#paypal-button-container');
        }
        
        async function initiateACH() {
            const amount = parseFloat(document.getElementById('paymentAmount').value);
            
            if (!amount || amount < 100) {
                showStatus('paymentStatus', 'Minimum $100 for bank transfer', 'error');
                return;
            }
            
            if (typeof Plaid === 'undefined') {
                showStatus('paymentStatus', 'Plaid SDK not loaded', 'error');
                return;
            }
            
            try {
                showStatus('paymentStatus', 'Initializing bank connection...', 'info');
                
                const response = await fetchAPI('/api/payment/plaid/create-link-token', {
                    method: 'POST'
                });
                
                if (!response || !response.link_token) {
                    throw new Error('Failed to get Plaid token');
                }
                
                const handler = Plaid.create({
                    token: response.link_token,
                    onSuccess: async (public_token) => {
                        try {
                            await fetchAPI('/api/payment/plaid/exchange-token', {
                                method: 'POST',
                                body: JSON.stringify({ public_token, amount })
                            });
                            showStatus('paymentStatus', 'Bank transfer initiated! Funds will arrive in 3-5 days.', 'success');
                        } catch (error) {
                            showStatus('paymentStatus', 'Failed to process transfer: ' + error.message, 'error');
                        }
                    },
                    onExit: (err) => {
                        if (err) {
                            showStatus('paymentStatus', 'Bank connection cancelled', 'info');
                        }
                    }
                });
                
                handler.open();
            } catch (error) {
                showStatus('paymentStatus', 'Plaid error: ' + error.message, 'error');
            }
        }
        
        async function processCashApp() {
            const amount = parseFloat(document.getElementById('paymentAmount').value);
            const cashtag = document.getElementById('cashtag').value;
            
            if (!amount || !cashtag) {
                showStatus('paymentStatus', 'Enter amount and $Cashtag', 'error');
                return;
            }
            
            try {
                const response = await fetchAPI('/api/payment/cashapp/create', {
                    method: 'POST',
                    body: JSON.stringify({ amount, cashtag })
                });
                
                if (response && response.payment_url) {
                    window.location.href = response.payment_url;
                } else {
                    throw new Error('Failed to create Cash App payment');
                }
            } catch (error) {
                showStatus('paymentStatus', 'Cash App error: ' + error.message, 'error');
            }
        }
        
        // ========== SWEEP OPERATIONS ==========
        
        async function executeSweep(force = false) {
            const chainId = parseInt(document.getElementById('sweepChain').value);
            const address = document.getElementById('sweepAddress').value.trim();
            
            // Validation
            if (!address || !address.match(/^0x[a-fA-F0-9]{40}$/)) {
                showStatus('sweepStatus', 'Enter valid Ethereum address (0x...)', 'error');
                return;
            }
            
            if (!authToken) {
                showStatus('sweepStatus', 'Please connect your wallet first', 'error');
                switchTab('wallets', { target: document.querySelector('.tab-btn') });
                return;
            }
            
            // Check if address is already being swept
            const sweepKey = `${address}-${chainId}`;
            if (sweepQueue.includes(sweepKey)) {
                showStatus('sweepStatus', 'Sweep already in progress for this address', 'info');
                return;
            }
            
            sweepQueue.push(sweepKey);
            
            try {
                showStatus('sweepStatus', 'Validating sweep...', 'info');
                
                // Simulate the sweep first
                const simulation = await fetchAPI('/api/sweeper/simulate', {
                    method: 'POST',
                    body: JSON.stringify({
                        chainId: chainId,
                        address: address
                    })
                });
                
                if (simulation && !force) {
                    // Show simulation results
                    if (parseFloat(simulation.balance) === 0) {
                        showStatus('sweepStatus', 'Address has zero balance. Use Force Sweep to override.', 'error');
                        sweepQueue = sweepQueue.filter(k => k !== sweepKey);
                        return;
                    }
                    
                    if (simulation.gasEstimate) {
                        const gasCost = parseFloat(simulation.gasEstimate);
                        const balance = parseFloat(simulation.balance);
                        if (gasCost >= balance) {
                            showStatus('sweepStatus', `Insufficient balance for gas. Need: ${gasCost} ETH, Have: ${balance} ETH`, 'error');
                            sweepQueue = sweepQueue.filter(k => k !== sweepKey);
                            return;
                        }
                    }
                    
                    // Ask for confirmation
                    const confirmMsg = `Sweep Details:\n` +
                        `Address: ${address}\n` +
                        `Chain: ${getNetworkName(chainId)}\n` +
                        `Balance: ${simulation.balance} ETH\n` +
                        `Est. Gas: ${simulation.gasEstimate} ETH\n` +
                        `Net Amount: ${simulation.netAmount} ETH\n\n` +
                        `Continue?`;
                    
                    if (!confirm(confirmMsg)) {
                        sweepQueue = sweepQueue.filter(k => k !== sweepKey);
                        showStatus('sweepStatus', 'Sweep cancelled', 'info');
                        return;
                    }
                }
                
                showStatus('sweepStatus', 'Executing sweep...', 'info');
                
                const result = await fetchAPI('/api/sweeper/sweep', {
                    method: 'POST',
                    body: JSON.stringify({
                        chainId: chainId,
                        address: address,
                        force: force,
                        priority: force ? 'high' : 'normal',
                        simulation: simulation
                    })
                });
                
                if (result) {
                    if (result.txHash) {
                        showStatus('sweepStatus', `Sweep executed! TX: ${result.txHash}`, 'success');
                        
                        // Add explorer link
                        const explorerLink = getExplorerLink(chainId, result.txHash);
                        const statusEl = document.getElementById('sweepStatus');
                        statusEl.innerHTML = `Sweep executed! <a href="${explorerLink}" target="_blank" style="color: var(--primary); text-decoration: underline;">View on Explorer</a>`;
                    } else if (result.sweepId) {
                        showStatus('sweepStatus', `Sweep queued (ID: ${result.sweepId})`, 'success');
                    } else {
                        showStatus('sweepStatus', 'Sweep initiated successfully', 'success');
                    }
                    
                    await loadSweepHistory();
                    await loadQuickStats();
                }
            } catch (error) {
                showStatus('sweepStatus', 'Sweep failed: ' + error.message, 'error');
            } finally {
                sweepQueue = sweepQueue.filter(k => k !== sweepKey);
            }
        }
        
        function getExplorerLink(chainId, txHash) {
            const explorers = {
                1: 'https://etherscan.io/tx/',
                56: 'https://bscscan.com/tx/',
                137: 'https://polygonscan.com/tx/',
                42161: 'https://arbiscan.io/tx/',
                10: 'https://optimistic.etherscan.io/tx/',
                43114: 'https://snowtrace.io/tx/',
                8453: 'https://basescan.org/tx/',
                250: 'https://ftmscan.com/tx/'
            };
            return (explorers[chainId] || 'https://etherscan.io/tx/') + txHash;
        }
        
        let batchMode = false;
        
        function toggleBatchMode() {
            batchMode = !batchMode;
            
            document.getElementById('sweepAddress').style.display = batchMode ? 'none' : 'block';
            document.getElementById('batchSweepAddresses').style.display = batchMode ? 'block' : 'none';
            document.getElementById('batchSweepBtn').style.display = batchMode ? 'inline-block' : 'none';
        }
        
        async function executeBatchSweep() {
            const textarea = document.getElementById('batchSweepAddresses');
            const addresses = textarea.value
                .split('\n')
                .map(a => a.trim())
                .filter(a => a && a.match(/^0x[a-fA-F0-9]{40}$/));
            
            if (addresses.length === 0) {
                showStatus('sweepStatus', 'No valid addresses found', 'error');
                return;
            }
            
            if (!confirm(`Execute batch sweep for ${addresses.length} addresses?`)) {
                return;
            }
            
            const chainId = parseInt(document.getElementById('sweepChain').value());
            let successful = 0;
            let failed = 0;
            
            showStatus('sweepStatus', `Processing batch: 0/${addresses.length}`, 'info');
            
            for (let i = 0; i < addresses.length; i++) {
                const address = addresses[i];
                
                try {
                    showStatus('sweepStatus', `Processing ${i + 1}/${addresses.length}: ${address.substring(0, 10)}...`, 'info');
                    
                    const result = await fetchAPI('/api/sweeper/sweep', {
                        method: 'POST',
                        body: JSON.stringify({
                            chainId: chainId,
                            address: address,
                            force: false,
                            priority: 'normal',
                            batch: true
                        })
                    });
                    
                    if (result) {
                        successful++;
                    }
                    
                    // Small delay between requests
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                } catch (error) {
                    console.error(`Failed to sweep ${address}:`, error);
                    failed++;
                }
            }
            
            showStatus('sweepStatus', `Batch complete: ${successful} successful, ${failed} failed`, successful > failed ? 'success' : 'warning');
            await loadSweepHistory();
            await loadQuickStats();
        }
        
        let sweepHistoryPage = 0;
        const sweepHistoryLimit = 20;
        let sweepHistoryFilter = 'all';
        
        async function loadSweepHistory(loadMore = false) {
            if (!loadMore) {
                sweepHistoryPage = 0;
                document.getElementById('sweepHistory').innerHTML = '';
            }
            
            document.getElementById('sweepLoading').classList.add('show');
            
            try {
                const params = new URLSearchParams({
                    limit: sweepHistoryLimit,
                    offset: sweepHistoryPage * sweepHistoryLimit
                });
                
                if (sweepHistoryFilter !== 'all') {
                    params.append('status', sweepHistoryFilter);
                }
                
                const data = await fetchAPI(`/api/database/sweeps?${params}`);
                
                if (data && data.sweeps && data.sweeps.length > 0) {
                    let html = '';
                    
                    if (sweepHistoryPage === 0) {
                        html += '<div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">';
                        html += '<button class="btn btn-secondary" onclick="filterSweeps(\'all\')">All</button>';
                        html += '<button class="btn btn-secondary" onclick="filterSweeps(\'completed\')">Completed</button>';
                        html += '<button class="btn btn-secondary" onclick="filterSweeps(\'pending\')">Pending</button>';
                        html += '<button class="btn btn-secondary" onclick="filterSweeps(\'failed\')">Failed</button>';
                        html += '<button class="btn btn-secondary" onclick="exportSweeps()">Export CSV</button>';
                        html += '</div>';
                        html += '<table><thead><tr><th>Time</th><th>Chain</th><th>Address</th><th>Amount</th><th>Status</th><th>TX Hash</th></tr></thead><tbody>';
                    }
                    
                    data.sweeps.forEach(sweep => {
                        const date = new Date(sweep.created_at);
                        const time = date.toLocaleString();
                        const statusColor = sweep.status === 'completed' ? 'var(--primary)' : 
                                          sweep.status === 'failed' ? 'var(--error)' : 'var(--warning)';
                        const addr = sweep.address || 'Unknown';
                        const shortAddr = addr.substring(0, 6) + '...' + addr.substring(addr.length - 4);
                        
                        html += `<tr>
                            <td>${time}</td>
                            <td>${sweep.chain_name || getNetworkName(sweep.chain_id) || 'Ethereum'}</td>
                            <td title="${addr}">${shortAddr}</td>
                            <td>${parseFloat(sweep.amount || 0).toFixed(4)} ${sweep.token || 'ETH'}</td>
                            <td style="color: ${statusColor}">${sweep.status}</td>
                            <td>${sweep.tx_hash ? 
                                `<a href="${getExplorerLink(sweep.chain_id || 1, sweep.tx_hash)}" target="_blank" style="color: var(--primary)">
                                    ${sweep.tx_hash.substring(0, 10)}...
                                </a>` : 
                                'Pending'}</td>
                        </tr>`;
                    });
                    
                    if (sweepHistoryPage === 0) {
                        html += '</tbody></table>';
                    }
                    
                    if (data.hasMore || data.sweeps.length === sweepHistoryLimit) {
                        html += '<button class="btn btn-secondary" onclick="loadSweepHistory(true)" style="margin-top: 1rem;">Load More</button>';
                    }
                    
                    if (loadMore) {
                        document.querySelector('#sweepHistory tbody').innerHTML += html;
                    } else {
                        document.getElementById('sweepHistory').innerHTML = html;
                    }
                    
                    sweepHistoryPage++;
                } else if (sweepHistoryPage === 0) {
                    document.getElementById('sweepHistory').innerHTML = '<p style="text-align: center; color: var(--text-dim);">No sweeps found</p>';
                }
            } catch (error) {
                if (sweepHistoryPage === 0) {
                    document.getElementById('sweepHistory').innerHTML = 
                        '<p style="text-align: center; color: var(--error);">Failed to load sweep history: ' + error.message + '</p>';
                }
            }
            
            document.getElementById('sweepLoading').classList.remove('show');
        }
        
        function filterSweeps(status) {
            sweepHistoryFilter = status;
            loadSweepHistory();
        }
        
        async function exportSweeps() {
            try {
                const response = await fetch(`${API_BASE}/api/database/sweeps/export`, {
                    headers: {
                        'Authorization': `Bearer ${authToken}`
                    }
                });
                
                if (!response.ok) throw new Error('Export failed');
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `sweeps-export-${Date.now()}.csv`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
                
                showStatus('sweepStatus', 'Export downloaded successfully', 'success');
            } catch (error) {
                showStatus('sweepStatus', 'Export failed: ' + error.message, 'error');
            }
        }
        
        // ========== ANALYTICS ==========
        
        async function loadAnalytics() {
            try {
                const data = await fetchAPI('/api/database/analytics?period=7d');
                
                if (data) {
                    // Update summary metrics
                    document.getElementById('totalSweeps').textContent = data.totalSweeps || 0;
                    document.getElementById('totalVolume').textContent = '$' + (parseFloat(data.totalVolume) || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});
                    document.getElementById('successRate').textContent = (parseFloat(data.successRate) || 99.9).toFixed(1) + '%';
                    
                    // Update active chains
                    if (data.activeChains) {
                        document.getElementById('activeChains').textContent = data.activeChains;
                    }
                    
                    // Create or update activity chart
                    if (!activityChart && typeof Chart !== 'undefined') {
                        const ctx = document.getElementById('activityChart').getContext('2d');
                        
                        activityChart = new Chart(ctx, {
                            type: 'line',
                            data: {
                                labels: data.daily?.labels || ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
                                datasets: [{
                                    label: 'Sweeps',
                                    data: data.daily?.sweeps || [0, 0, 0, 0, 0, 0, 0],
                                    borderColor: '#00ff88',
                                    backgroundColor: 'rgba(0, 255, 136, 0.1)',
                                    tension: 0.4,
                                    fill: true,
                                    yAxisID: 'y'
                                }, {
                                    label: 'Volume ($)',
                                    data: data.daily?.volume || [0, 0, 0, 0, 0, 0, 0],
                                    borderColor: '#0088ff',
                                    backgroundColor: 'rgba(0, 136, 255, 0.1)',
                                    tension: 0.4,
                                    fill: true,
                                    yAxisID: 'y1'
                                }]
                            },
                            options: {
                                responsive: true,
                                maintainAspectRatio: false,
                                interaction: {
                                    mode: 'index',
                                    intersect: false
                                },
                                plugins: {
                                    legend: { 
                                        labels: { color: '#e0e6ed' }
                                    },
                                    tooltip: {
                                        backgroundColor: 'rgba(10, 14, 39, 0.9)',
                                        titleColor: '#00ff88',
                                        bodyColor: '#e0e6ed',
                                        borderColor: '#00ff88',
                                        borderWidth: 1
                                    }
                                },
                                scales: {
                                    y: {
                                        type: 'linear',
                                        display: true,
                                        position: 'left',
                                        ticks: { color: '#8892a6' },
                                        grid: { color: 'rgba(0, 255, 136, 0.1)' },
                                        title: {
                                            display: true,
                                            text: 'Number of Sweeps',
                                            color: '#00ff88'
                                        }
                                    },
                                    y1: {
                                        type: 'linear',
                                        display: true,
                                        position: 'right',
                                        ticks: { color: '#8892a6' },
                                        grid: { drawOnChartArea: false },
                                        title: {
                                            display: true,
                                            text: 'Volume ($)',
                                            color: '#0088ff'
                                        }
                                    },
                                    x: {
                                        ticks: { color: '#8892a6' },
                                        grid: { color: 'rgba(0, 255, 136, 0.1)' }
                                    }
                                }
                            }
                        });
                    } else if (activityChart && data.daily) {
                        // Update existing chart
                        activityChart.data.labels = data.daily.labels;
                        activityChart.data.datasets[0].data = data.daily.sweeps || data.daily.values;
                        if (data.daily.volume) {
                            activityChart.data.datasets[1].data = data.daily.volume;
                        }
                        activityChart.update();
                    }
                    
                    // Load chain distribution if available
                    if (data.chainDistribution) {
                        createChainDistributionChart(data.chainDistribution);
                    }
                }
            } catch (error) {
                console.error('Analytics error:', error);
                showStatus('adminStatus', 'Failed to load analytics: ' + error.message, 'error');
            }
        }
        
        let chainDistributionChart;
        
        function createChainDistributionChart(chainData) {
            const container = document.querySelector('#analytics .section:last-child');
            
            if (!container.querySelector('#chainDistChart')) {
                const chartSection = document.createElement('div');
                chartSection.className = 'section';
                chartSection.innerHTML = `
                    <h3 style="color: var(--primary); margin-bottom: 1rem;">Chain Distribution</h3>
                    <div class="chart-container">
                        <canvas id="chainDistChart"></canvas>
                    </div>
                `;
                container.parentElement.appendChild(chartSection);
            }
            
            if (!chainDistributionChart && typeof Chart !== 'undefined') {
                const ctx = document.getElementById('chainDistChart').getContext('2d');
                chainDistributionChart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: chainData.labels || [],
                        datasets: [{
                            data: chainData.values || [],
                            backgroundColor: [
                                'rgba(0, 255, 136, 0.8)',
                                'rgba(0, 136, 255, 0.8)',
                                'rgba(255, 170, 0, 0.8)',
                                'rgba(255, 0, 68, 0.8)',
                                'rgba(170, 0, 255, 0.8)',
                                'rgba(0, 255, 255, 0.8)',
                                'rgba(255, 136, 0, 0.8)',
                                'rgba(136, 255, 0, 0.8)'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: { color: '#e0e6ed' }
                            }
                        }
                    }
                });
            } else if (chainDistributionChart) {
                chainDistributionChart.data.labels = chainData.labels;
                chainDistributionChart.data.datasets[0].data = chainData.values;
                chainDistributionChart.update();
            }
        }
        
        // ========== ADMIN FUNCTIONS ==========
        
        async function pauseAllSweeps() {
            if (!confirm('Pause all sweep operations? This will stop all active and queued sweeps.')) return;
            
            try {
                const response = await fetchAPI('/api/sweeper/pause', { 
                    method: 'POST',
                    body: JSON.stringify({
                        reason: 'Manual pause by admin',
                        timestamp: Date.now()
                    })
                });
                
                if (response && response.success) {
                    showStatus('adminStatus', `All sweeps paused. ${response.activeSweeps || 0} sweeps stopped.`, 'success');
                    await checkServices();
                } else {
                    showStatus('adminStatus', 'Sweeps paused', 'success');
                }
            } catch (error) {
                showStatus('adminStatus', 'Failed to pause sweeps: ' + error.message, 'error');
            }
        }
        
        async function resumeAllSweeps() {
            try {
                const response = await fetchAPI('/api/sweeper/resume', { 
                    method: 'POST',
                    body: JSON.stringify({
                        resumedBy: 'admin',
                        timestamp: Date.now()
                    })
                });
                
                if (response && response.success) {
                    showStatus('adminStatus', `Sweeps resumed. ${response.queuedSweeps || 0} sweeps in queue.`, 'success');
                    await checkServices();
                } else {
                    showStatus('adminStatus', 'Sweeps resumed', 'success');
                }
            } catch (error) {
                showStatus('adminStatus', 'Failed to resume sweeps: ' + error.message, 'error');
            }
        }
        
        async function checkServices() {
            const services = [
                { name: 'API Gateway', path: '/health' },
                { name: 'Monitor Service', path: '/api/monitor/health' },
                { name: 'Sweeper Service', path: '/api/sweeper/health' },
                { name: 'Notification Service', path: '/api/notification/health' },
                { name: 'Database Service', path: '/api/database/health' },
                { name: 'WAF Service', path: '/api/waf/health' }
            ];
            
            let html = '<table><thead><tr><th>Service</th><th>Status</th><th>Response Time</th><th>Details</th></tr></thead><tbody>';
            
            for (const service of services) {
                const startTime = Date.now();
                try {
                    const response = await fetchAPI(service.path);
                    const responseTime = Date.now() - startTime;
                    const status = response ? 'Running' : 'Down';
                    const color = response ? 'var(--primary)' : 'var(--error)';
                    
                    let details = '';
                    if (response) {
                        if (response.uptime) {
                            const uptimeHours = Math.floor(response.uptime / 3600);
                            details = `Uptime: ${uptimeHours}h`;
                        }
                        if (response.version) {
                            details += (details ? ', ' : '') + `v${response.version}`;
                        }
                        if (response.status === 'degraded') {
                            details += ' ‚ö†Ô∏è DEGRADED';
                        }
                    }
                    
                    html += `<tr>
                        <td>${service.name}</td>
                        <td style="color: ${color}">‚úì ${status}</td>
                        <td>${responseTime}ms</td>
                        <td style="color: var(--text-dim); font-size: 0.9rem;">${details}</td>
                    </tr>`;
                } catch (error) {
                    const responseTime = Date.now() - startTime;
                    html += `<tr>
                        <td>${service.name}</td>
                        <td style="color: var(--error)">‚úó Down</td>
                        <td>${responseTime}ms</td>
                        <td style="color: var(--error); font-size: 0.9rem;">${error.message}</td>
                    </tr>`;
                }
            }
            
            html += '</tbody></table>';
            document.getElementById('serviceStatus').innerHTML = html;
        }
        
        async function loadWAFStats() {
            try {
                const data = await fetchAPI('/api/waf/stats');
                
                if (data) {
                    document.getElementById('blockedRequests').textContent = data.blockedRequests?.toLocaleString() || 0;
                    document.getElementById('blacklistedIPs').textContent = data.blacklistedIPs?.toLocaleString() || 0;
                    document.getElementById('whitelistedIPs').textContent = data.whitelistedIPs?.toLocaleString() || 0;
                    
                    const threatLevel = data.threatLevel || 'Low';
                    const threatColors = {
                        'Low': 'var(--primary)',
                        'Medium': 'var(--warning)',
                        'High': 'var(--error)',
                        'Critical': 'var(--error)'
                    };
                    
                    const threatEl = document.getElementById('threatLevel');
                    threatEl.textContent = threatLevel;
                    threatEl.style.color = threatColors[threatLevel] || 'var(--primary)';
                    
                    // Add recent blocks if available
                    if (data.recentBlocks && data.recentBlocks.length > 0) {
                        addRecentBlocksSection(data.recentBlocks);
                    }
                }
            } catch (error) {
                console.error('Failed to load WAF stats:', error);
            }
        }
        
        function addRecentBlocksSection(blocks) {
            const container = document.querySelector('#admin .section:last-child');
            let section = document.getElementById('recentBlocksSection');
            
            if (!section) {
                section = document.createElement('div');
                section.id = 'recentBlocksSection';
                section.className = 'section';
                section.style.marginTop = '2rem';
                container.parentElement.appendChild(section);
            }
            
            let html = '<h3 style="color: var(--primary); margin-bottom: 1rem;">Recent Blocked Requests</h3>';
            html += '<table><thead><tr><th>Time</th><th>IP Address</th><th>Reason</th><th>Country</th></tr></thead><tbody>';
            
            blocks.slice(0, 10).forEach(block => {
                const time = new Date(block.timestamp).toLocaleString();
                html += `<tr>
                    <td>${time}</td>
                    <td>${block.ip}</td>
                    <td>${block.reason}</td>
                    <td>${block.country || 'Unknown'}</td>
                </tr>`;
            });
            
            html += '</tbody></table>';
            section.innerHTML = html;
        }
        
        async function emergencyShutdown() {
            if (!confirm('‚ö†Ô∏è EMERGENCY SHUTDOWN ‚ö†Ô∏è\n\nThis will:\n- Stop all sweep operations\n- Disconnect all monitoring\n- Close all active connections\n\nOnly use in case of security incident or critical failure.\n\nContinue?')) {
                return;
            }
            
            try {
                // Pause all sweeps
                await fetchAPI('/api/sweeper/pause', { 
                    method: 'POST',
                    body: JSON.stringify({
                        emergency: true,
                        reason: 'Emergency shutdown by admin',
                        timestamp: Date.now()
                    })
                });
                
                // Disable monitoring
                await fetchAPI('/api/monitor/pause', { method: 'POST' });
                
                // Send emergency notification
                await fetchAPI('/api/notification/alert', {
                    method: 'POST',
                    body: JSON.stringify({
                        severity: 'critical',
                        message: 'Emergency shutdown initiated',
                        timestamp: Date.now()
                    })
                });
                
                showStatus('adminStatus', 'üö® Emergency shutdown complete - all operations stopped', 'error');
                
                // Refresh service status
                setTimeout(() => checkServices(), 2000);
            } catch (error) {
                showStatus('adminStatus', 'Emergency shutdown failed: ' + error.message, 'error');
            }
        }
        
        // ========== HOME FUNCTIONS ==========
        
        async function loadSystemStatus() {
            try {
                const response = await fetchAPI('/health');
                
                if (response && response.status === 'healthy') {
                    let html = '<p style="color: var(--primary); font-weight: bold;">‚úì All systems operational</p>';
                    
                    if (response.services) {
                        const healthy = response.services.filter(s => s.status === 'healthy').length;
                        const total = response.services.length;
                        html += `<p style="color: var(--text-dim); margin-top: 0.5rem;">Services: ${healthy}/${total} healthy</p>`;
                    }
                    
                    if (response.uptime) {
                        const uptimeHours = Math.floor(response.uptime / 3600);
                        const uptimeDays = Math.floor(uptimeHours / 24);
                        html += `<p style="color: var(--text-dim);">Uptime: ${uptimeDays}d ${uptimeHours % 24}h</p>`;
                    }
                    
                    html += `<p style="color: var(--text-dim); font-size: 0.85rem; margin-top: 0.5rem;">Last checked: ${new Date().toLocaleTimeString()}</p>`;
                    
                    document.getElementById('systemStatus').innerHTML = html;
                } else if (response && response.status === 'degraded') {
                    document.getElementById('systemStatus').innerHTML = 
                        '<p style="color: var(--warning);">‚ö† System running in degraded mode</p>' +
                        '<p style="color: var(--text-dim); margin-top: 0.5rem;">' + (response.message || 'Some services may be affected') + '</p>';
                } else {
                    throw new Error('Unhealthy status');
                }
            } catch (error) {
                document.getElementById('systemStatus').innerHTML = 
                    '<p style="color: var(--error);">‚úó System offline or unreachable</p>' +
                    '<p style="color: var(--text-dim); margin-top: 0.5rem;">' + error.message + '</p>' +
                    '<button class="btn btn-secondary" onclick="loadSystemStatus()" style="margin-top: 1rem;">Retry</button>';
            }
        }
        
        async function loadQuickStats() {
            try {
                const [analytics, monitor] = await Promise.all([
                    fetchAPI('/api/database/analytics?period=24h').catch(() => null),
                    fetchAPI('/api/monitor/stats').catch(() => null)
                ]);
                
                let html = '';
                
                if (analytics) {
                    html += `<p>Total Sweeps (24h): <strong style="color: var(--primary)">${(analytics.totalSweeps || 0).toLocaleString()}</strong></p>`;
                    html += `<p>Success Rate: <strong style="color: var(--primary)">${(parseFloat(analytics.successRate) || 99.9).toFixed(1)}%</strong></p>`;
                    html += `<p>Total Volume: <strong style="color: var(--primary)">$${(parseFloat(analytics.totalVolume) || 0).toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2})}</strong></p>`;
                }
                
                if (monitor) {
                    html += `<p>Active Wallets: <strong style="color: var(--primary)">${(monitor.activeWallets || 0).toLocaleString()}</strong></p>`;
                    html += `<p>Monitored Addresses: <strong style="color: var(--primary)">${(monitor.monitoredAddresses || 0).toLocaleString()}</strong></p>`;
                }
                
                if (!analytics && !monitor) {
                    html = '<p style="color: var(--error);">Unable to load stats</p>';
                }
                
                html += `<p style="color: var(--text-dim); font-size: 0.85rem; margin-top: 1rem;">Last updated: ${new Date().toLocaleTimeString()}</p>`;
                
                document.getElementById('quickStats').innerHTML = html;
            } catch (error) {
                document.getElementById('quickStats').innerHTML = 
                    '<p style="color: var(--error);">Failed to load stats</p>' +
                    '<button class="btn btn-secondary" onclick="loadQuickStats()" style="margin-top: 0.5rem;">Retry</button>';
            }
        }
        
        // ========== UTILITY FUNCTIONS ==========
        
        let ws;
        let wsReconnectAttempts = 0;
        const MAX_WS_RECONNECT = 5;
        
        function initWebSocket() {
            if (!authToken) return;
            
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsHost = API_BASE.replace('http://', '').replace('https://', '');
            
            try {
                ws = new WebSocket(`${wsProtocol}//${wsHost}/ws?token=${authToken}`);
                
                ws.onopen = () => {
                    console.log('WebSocket connected');
                    wsReconnectAttempts = 0;
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        handleWebSocketMessage(data);
                    } catch (error) {
                        console.error('WebSocket message error:', error);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
                
                ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    if (wsReconnectAttempts < MAX_WS_RECONNECT) {
                        wsReconnectAttempts++;
                        setTimeout(() => initWebSocket(), 5000 * wsReconnectAttempts);
                    }
                };
            } catch (error) {
                console.error('Failed to initialize WebSocket:', error);
            }
        }
        
        function handleWebSocketMessage(data) {
            switch(data.type) {
                case 'sweep_complete':
                    handleSweepComplete(data.payload);
                    break;
                case 'sweep_failed':
                    handleSweepFailed(data.payload);
                    break;
                case 'balance_update':
                    handleBalanceUpdate(data.payload);
                    break;
                case 'alert':
                    handleAlert(data.payload);
                    break;
                default:
                    console.log('Unknown WebSocket message:', data);
            }
        }
        
        function handleSweepComplete(payload) {
            if (document.getElementById('sweeps').classList.contains('active')) {
                loadSweepHistory();
            }
            showStatus('sweepStatus', `Sweep completed! TX: ${payload.txHash}`, 'success');
            loadQuickStats();
        }
        
        function handleSweepFailed(payload) {
            showStatus('sweepStatus', `Sweep failed: ${payload.reason}`, 'error');
            if (document.getElementById('sweeps').classList.contains('active')) {
                loadSweepHistory();
            }
        }
        
        function handleBalanceUpdate(payload) {
            if (currentAccount && payload.address.toLowerCase() === currentAccount.toLowerCase()) {
                const balance = web3.utils.fromWei(payload.balance, 'ether');
                document.getElementById('walletBalance').textContent = balance + ' ETH';
            }
        }
        
        function handleAlert(payload) {
            showStatus('adminStatus', payload.message, payload.severity || 'info');
        }
        
        function showStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            if (!element) return;
            
            element.className = `status-message status-${type} show`;
            element.textContent = message;
            
            setTimeout(() => {
                element.classList.remove('show');
            }, 5000);
        }
    </script>
</body>
</html>
